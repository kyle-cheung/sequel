Let me refresh your memory with our goal, the current project directory, and our code:
Goal:
At a high level my goal is: create a tool that accepts text input to query a database.
This can be achieved by a few milestones
1. Establish a connection to a database: let's work on this part first, and this is achieved by accepting, uploading, processing, and displaying the CSV uploads that represent tables in a database
2. Have a text input and response from the app
3. Send the text input and relevant schema information via API to OpenAI GPT3 to then create the SQL query which we will pass to the database

We just accomplished most of 1.

Project directory:
sequel/
|-- backend/
|   |-- app.py
|   |-- database.py
|   |-- query.py
|-- frontend/
|   |-- templates/
|   |   |-- index.html
|   |-- static/
|   |   |-- styles.css
|   |   |-- upload.js
|   |   |-- tables.js
|   |   |-- query.js

Code:
app.py
```
from flask import Flask, request, jsonify, render_template, json
import os
import database
import re
import query

static_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'frontend', 'static'))

app = Flask(__name__, template_folder='../frontend/templates', static_url_path='/static', static_folder=static_path)

@app.route("/", methods=["GET"])
def index():
    return render_template("index.html")

@app.route("/upload_csv", methods=["POST"])
def upload_csv():
    file = request.files["file"]
    table_name = request.form["table_name"]
    
    if not table_name or not re.match("^[a-zA-Z_][a-zA-Z0-9_]*$", table_name):
        return jsonify({"status": "error", "message": "Invalid table name"})
        
    sample_data = database.save_csv_to_db(file, table_name)
    return jsonify({"status": "success", "message": f"CSV file uploaded successfully as {table_name}", "sample_data": sample_data})

@app.route("/tables", methods=["GET"])
def get_tables():
    table_names = database.get_tables()
    return jsonify({"tables": table_names})

@app.route("/delete_table", methods=["DELETE"])
def delete_table():
    table_name = request.args.get("table_name")
    if table_name:
        try:
            database.delete_table(table_name)
            return jsonify({"status": "success", "message": f"Table {table_name} deleted successfully"})
        except Exception as e:
            print(e)
            return jsonify({"status": "error", "message": "An error occurred while deleting the table"})
    else:
        return jsonify({"status": "error", "message": "No table name provided"})

@app.route("/store_user_query", methods=["POST"])
def store_user_query():
    user_query = request.form["user_query"]
    query_response = query.store_user_query(user_query)
    query_response["sql_results"] = json.dumps(query_response["sql_results"])
    return jsonify({"status": "success", "message": query_response})

if __name__ == "__main__":
    app.run(debug=True)
```

database.py:
```
import sqlite3
import pandas as pd

DATABASE_FILE = "bi_tool.db"

def save_csv_to_db(file, table_name):
    df = pd.read_csv(file)

    with sqlite3.connect(DATABASE_FILE) as conn:
        df.to_sql(table_name, conn, if_exists="replace", index=False)

    sample_data = df.head(5).to_json(orient="records")
    return sample_data

def get_tables():
    with sqlite3.connect(DATABASE_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = [row[0] for row in cursor.fetchall()]
    return tables

def delete_table(table_name):
    with sqlite3.connect(DATABASE_FILE) as conn:
        cursor = conn.cursor()

        # Check if the table exists
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table_name,))
        result = cursor.fetchone()

        if result:
            # If the table exists, delete it
            cursor.execute(f"DROP TABLE {table_name}")
            return "success"
        else:
            return "not found"

def fetch_all_table_structure():
    """
    This function fetches all of the tables structure of the database and returns as a dictionary
    Note that this only works for SQLite
    :return:
    """


    with sqlite3.connect(DATABASE_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        table_structure = {}
        for table in tables:
            cursor.execute(f"PRAGMA table_info({table[0]})")
            table_structure[table[0]] = cursor.fetchall()
        return table_structure
```

query.py:
```
import sqlite3
import pandas as pd
import requests
import database
from database import fetch_all_table_structure

sequel_db = 'bi_tool.db'
textcortex_api_key = 'Bearer gAAAAABkMFEMlesLUwl9Uy6K4zZYUxtxsazlYOpSKP1_HASvA5EuoI0e2Xsd6o5EtWLXayMR_Rrqa1nT612wCsesvWb-gMf_U865T9HXIMuPf5RGmsfJBnRaEQTq5jaktjDO50tBVvRy'
textcortex_sql_generator_endpoint = "https://api.textcortex.com/v1/codes"

def store_user_query(query):
    response, sql_response, sql_results = generate_sql_query(query)
    print(sql_results)
    return {
        "sql_query" : sql_response,
        "sql_results": sql_results
    }


def construct_textcortex_api_data(question):
    table_structure = database.fetch_all_table_structure()
    payload = {
        "max_tokens": 1024,
        "mode": "python",
        "model": "icortex-1",
        "n": 1,
        "temperature": 0,
        "text": "SQL Table Structure: " + str(table_structure) + " Question: " + question + " SQL Query: "
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": textcortex_api_key
    }

    return payload, headers

def generate_sql_query(question):
    """
    This function generates the SQL query by making a POST request to TextCortex API with
     the user question and the table structure
    :param question: user question
    :param table_structure: table structure of the database
    :return: SQL query
    """
    
    payload, headers = construct_textcortex_api_data(question)
    sql_query = ""

    response = requests.request("POST", textcortex_sql_generator_endpoint, json=payload, headers=headers)
    if response.status_code == 200:
        # Execute SQL query and display results
        sql_query = response.json()['data']['outputs'][0]['text']
        print(f"Generated SQL query: {sql_query}")
        sql_results = query_database(sql_query)
    else:
        print("Oops, that didn't work. Can you rephrase your question?", response.text)
    # Close connection
    return response, sql_query, sql_results

def query_database(sql_query):
    with sqlite3.connect(sequel_db) as conn:
        # Fetch the results using pandas
        df = pd.read_sql_query(sql_query, conn)

        return df.to_dict('records')
```

index.html:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequel</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script type="module" src="{{ url_for('static', filename='upload.js') }}" defer></script>
    <script type="module" src="{{ url_for('static', filename='tables.js') }}" defer></script>
    <script type="module" src="{{ url_for('static', filename='query.js') }}" defer></script>
</head>
<body>
    <div class="container">
        <div class="uploadContent">
            <h1>Sequel</h1> 
                <div class="input-container">
                    <input type="file" id="csvFile">
                    <div>
                        <input type="text" id="tableName" placeholder="Table name">
                        <button id="uploadButton">Upload</button>
                        <button id="clearButton">Clear</button>
                    </div>
                </div>
        </div>
        <div id="tableList"></div>
        <div id="message"></div>
        <div id="sampleData"></div>
        
    </div>

    <div class="query-history" id="queryHistory"></div>

    <div class="query-container">
        <input type="text" id="userQuery" placeholder="Enter your query">
        <button id="sendButton">Send</button>
    </div>
</body>
</html>
```

upload.js
```
import { fetchTables } from "./tables.js";

document.addEventListener("DOMContentLoaded", async () => {
    const tableListContainer = document.getElementById("tableList");
    await fetchTables(tableListContainer);
    
    const uploadButton = document.getElementById("uploadButton");
    uploadButton.addEventListener("click", async () => {
        const csvFileInput = document.getElementById("csvFile");
        const tableNameInput = document.getElementById("tableName");
        const file = csvFileInput.files[0];

        if (!file) {
            alert("Please select a CSV file.");
            return;
        }

        const formData = new FormData();
        formData.append("file", file);
        formData.append("table_name", tableNameInput.value);

        const response = await fetch("/upload_csv", {
            method: "POST",
            body: formData,
        });

        const result = await response.json();
        if (result.status === "success") {
            const messageDiv = document.getElementById("message");
            messageDiv.textContent = result.message;

            const sampleDataDiv = document.getElementById("sampleData");
            const sampleData = JSON.parse(result.sample_data);
            const table = createTableFromData(sampleData);
            sampleDataDiv.innerHTML = "";
            sampleDataDiv.appendChild(table);
            fetchTables(document.getElementById("tableList"));
        } else if (result.status === "exists") {
            const messageDiv = document.getElementById("message");
            messageDiv.textContent = result.message;
        }
        
    });

    const clearButton = document.getElementById("clearButton");
    clearButton.addEventListener("click", () => {
        const messageDiv = document.getElementById("message");
        const sampleDataDiv = document.getElementById("sampleData");
        messageDiv.textContent = "";
        sampleDataDiv.textContent = "";
    });
});

function createTableFromData(data) {
    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const tbody = document.createElement("tbody");

    const headerRow = document.createElement("tr");
    Object.keys(data[0]).forEach((key) => {
        const th = document.createElement("th");
        th.textContent = key;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    data.forEach((row) => {

        const tr = document.createElement("tr");
        Object.values(row).forEach((value) => {
            const td = document.createElement("td");
            td.textContent = value;
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });

    table.appendChild(thead);
    table.appendChild(tbody);
    return table;
}
```

tables.js:
```
export async function fetchTables(container) {
    //Clear the container before adding a new table
    container.innerHTML = "";

    const response = await fetch("/tables");
    const result = await response.json();
    const tableNames = result.tables;

    const table = createTableFromTableNames(tableNames);
    container.appendChild(table);
}

function createTableFromTableNames(tableNames) {
    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const tbody = document.createElement("tbody");

    const headerRow = document.createElement("tr");
    const th = document.createElement("th");
    th.textContent = "Table Name";
    headerRow.appendChild(th);
    thead.appendChild(headerRow);

    tableNames.forEach((tableName) => {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.textContent = tableName;
        tr.appendChild(td);

        // Create a delete button for each table.
        const deleteButton = document.createElement("button");
        deleteButton.textContent = "Delete";
        deleteButton.addEventListener("click", async () => {
            if (confirm(`Are you sure you want to delete ${tableName}?`)) {
                await deleteTable(tableName);
                fetchTables(document.getElementById("tableList"));
            }
        });

        // Add the delete button to the row.
        const buttonTd = document.createElement("td");
        buttonTd.appendChild(deleteButton);
        tr.appendChild(buttonTd);

        tbody.appendChild(tr);
    });

    table.appendChild(thead);
    table.appendChild(tbody);
    return table;
}

async function deleteTable(tableName) {
    const response = await fetch(`/delete_table?table_name=${tableName}`, {
        method: "DELETE",
    });

    const result = await response.json();
    if (result.status === "error") {
        alert("An error occurred while deleting the table.");
    }    
}
```

styles.css:
```
body {
    font-family: Helvetica, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    min-height: 100vh;
    align-items: center;
    justify-content: center;
    background-color: #f8f8f8;
}

.container {
    width: 80%;
    display: flex;
    flex-direction: column;
}

.input-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

table {
    border-collapse: collapse;
    margin: 20px auto; 
}

form {
    margin: 20px;
}

.uploadContent {
    position: fixed;
    top: 50px;
    width: 80%;
    left: 50%;
    height:100px;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    z-index: 10;
}

#tableList {
    position: fixed;
    font-family: Helvetica, sans-serif;
    top: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    width: 80%;
    left: 50%;
    transform: translateX(-50%);
}

#message {
    text-align: center;
    margin-top: 100px;
}

.query-container {
    position: fixed;
    bottom: 0;
    left: 200px;
    right: 200px;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: white;
    padding: 20px;
    box-shadow: 0 -2px 5px, rgba(0, 0, 0, 0.1);
}

#userQuery {
    width: 100%;
    height: 40px;
    padding: 5px;
    font-size: 18px;
}

#sendButton {
    height: 40px;
    margin-left: 10px;
    font-size: 18px;
}

.query-history {
    position: fixed;
    bottom: 90px;
    left: 200px;
    right: 200px;
    background-color: white;
    padding: 20px;
    box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
    overflow-y: auto;
    max-height: 800px;
}

.sequelResponse {
    text-align: right;
}
```

query.js:
```
// Listen for query send button
const sendButton = document.getElementById("sendButton");
sendButton.addEventListener("click", async () => {
    const userQueryInput = document.getElementById("userQuery");
    const userQuery = userQueryInput.value;

    //Clear the input
    userQueryInput.value = "";
    //Add user input to query history
    updateQueryHistory(userQuery);

    const response = await fetch("/store_user_query", {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
        },
        body: `user_query=${encodeURIComponent(userQuery)}`,
    });
    
    const result = await response.json();
    if (result.status === "success") {
        //Add response from app to query history
        const sqlResults = JSON.parse(result.message.sql_results);
        updateQueryHistory(`SQL Query: ${result.message.sql_query}`, true, sqlResults);
    } else {
        // Handle the error here (e.g., show an error message)
        updateQueryHistory("There was an error with your query", true)
    }
    // Scroll to the bottom of the queryHistory container
    scrollToBottom(queryHistory);
});

// Capture the "Enter" key press in the userQuery input
document.getElementById("userQuery").addEventListener("keydown", (event) => {
    if (event.key === "Enter") {
        event.preventDefault();
        sendButton.click();
    }
});


function updateQueryHistory(query, sequel_response = false, results = null) {
    const queryHistory = document.getElementById("queryHistory");
    const queryElement = document.createElement("p");
    const separator = document.createElement("hr");
    queryElement.textContent = query;

    if (sequel_response) {
        queryElement.classList.add("sequelResponse");
        const separator = document.createElement("hr");
        queryHistory.appendChild(separator);
    }

    queryHistory.appendChild(queryElement);
    // Scroll to the bottom of the queryHistory container
    scrollToBottom(queryHistory);

    if (results) {
        const resultsTable = document.createElement("table");
        const thead = document.createElement("thead");
        const tbody = document.createElement("tbody");

        // Create table header

        const headerRow = document.createElement("tr");
        Object.keys(results[0]).forEach((key) => {
            const th = document.createElement("th");
            th.textContent = key;
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);

        // Create table body
        results.forEach((row) => {
            const tr = document.createElement("tr");
            Object.values(row).forEach((value) => {
                const td = document.createElement("td");
                td.textContent = value;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        resultsTable.appendChild(thead);
        resultsTable.appendChild(tbody);
        queryHistory.appendChild(resultsTable);
        queryHistory.appendChild(separator);
    }
}

function scrollToBottom(element) {
    element.scrollTop = element.scrollHeight;
}
```

Let's try and get milestone 2. What we need to accomplish now is:
1.  Add a text input at the very bottom of the webpage, this text input container should be fixed. To the right of this text input should be a button that says send. This send button can also be triggered if the user pushes enter while in the text box
2. The text input should be stored in the backend into a variable called user_query. I think this should be in a new python file called query.py, what do you think?